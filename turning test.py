import mathimport libdw.util as utilimport libdw.sm as smimport libdw.gfx as gfxfrom soar.io import ioimport libdw.sonarDist as sonarDistimport urllib2import timeclass MySMClass(sm.SM):    startState=[1,0]      def sensors(self,inp):        return inp.sonars[0],inp.sonars[1],inp.sonars[2],inp.sonars[3],inp.sonars[4],inp.sonars[5]    def getNextValues(self, state, inp):        left,frontleft,front1,front2,frontright,right=self.sensors(inp)        print 'Current state: ', state[0],' Delay: ',state[1],'Front1,Front2:',front1,front2                ##move forward        if state[0]==1:                           if state[1]>=31:                state[0]=6                state[1]=0                z=io.Action(fvel=0,rvel=0)                return state,z            elif round(front1,2)<1 and round(front2,2)<1:     #end of the alley                    z=io.Action(fvel=0,rvel=0)                print 'front1,front2 ',front1,front2                state[1]=0                state[0]=3                return state, z                                    else:                                z=io.Action(fvel=0.5,rvel=0)                state[1]+=1                print 'state 1 else'                return state, z                                         ##rotate 180 degree at exposure        if state[0]==2:            print 'state 2 rotate 180'                                    #if junction counter= len(junction[path])            #swap destination and source                        if state[1]<=62:                z=io.Action(fvel=0,rvel=(math.pi)/4)                print 'rotate left'                state[1]+=1                return state, z            #            else:                state[0]=1                state[1]=0                z=io.Action(fvel=0,rvel=0)                                                                        return state,z                    #wait for 15 seconds        if state[0]==3:            print 'wait for 15 seconds'            #if state[1]<=150:            if state[1]<=20:                z=io.Action(fvel=0,rvel=0)                print 'waiting for ', state[1]/10 , 'seconds'                state[1]+=1                return state, z            else:                state[1]=0                z=io.Action(fvel=0,rvel=0)                print 'stop after turning'                state[0]=2                return state,z                        #proceed till junction        #proportional controller after junction                                                    #turn right        if state[0]==6:            print 'state 6'            if state[1]<=30:                z=io.Action(fvel=0,rvel=-(math.pi)/4)                print 'rotate right'                state[1]+=1                return state, z            #            else:                state[1]=0                z=io.Action(fvel=0,rvel=0)                print 'stop after turning'                state[0]=1                return state,z                                                                   mySM = MySMClass()mySM.name = 'brainSM'############################################################################          Brain methods#########################################################################def plotSonar(sonarNum):    robot.gfx.addDynamicPlotFunction(y=('sonar'+str(sonarNum),                                        lambda:                                         io.SensorInput().sonars[sonarNum]))# this function is called when the brain is (re)loadeddef setup():    robot.gfx = gfx.RobotGraphics(drawSlimeTrail=False, # slime trails                                  sonarMonitor=False) # sonar monitor widget        # set robot's behavior    robot.behavior = mySM# this function is called when the start button is pusheddef brainStart():    robot.behavior.start(traceTasks = robot.gfx.tasks())# this function is called 10 times per seconddef step():    inp = io.SensorInput()    robot.behavior.step(inp).execute()    io.done(robot.behavior.isDone())# called when the stop button is pusheddef brainStop():    pass# called when brain or world is reloaded (before setup)def shutdown():    pass